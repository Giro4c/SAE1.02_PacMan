using namespace std;
/*Collision Pac / Mur

Fonction bool  bool(collision ou non)
Paramètres :
- Struct de Pacman (contient PacPos, PacSize, PacDirection?)
- Map Param du PacMan (inclue les touches associée à chaque mouvement)
- Map Param General Jeu
*/

/**
 * @brief Procédure qui construit un vecteur contenant positions des murs pouvant potentiellement entrer en collision avec pacman parmis un vecteur de position de tous les murs
 * @param[in] Pac : La struct contenant les caractéristiques nécessaires aux évaluations de collision
 * @param[in] CaseSize : La largeur et longueur d'une case du plateau
 * @param[in] LocEntities : La struct contenant toutes les positions des entités sauf le pacman
 * @param[in] Parameters : La struct contenant tous les paramètres nécessaires à une partie
 * @fn unsigned CoNextMur (const PacMan & Pac, const unsigned & CaseSize, const vector<Cposition> & VecteurMurs, const CMyParam & Parameters);
*/

unsigned CoNextMur (const PacMan & Pac, const unsigned & CaseSize, const vector<Cposition> & VecteurMurs, const CMyParam & Parameters)
{
    // Si direction vers le haut
    if (Pac.DirectionActuelle == MapParamStrPac.find("TurnUp")->second){
        unsigned ValCoNextMurY (0);
        for (Cposition & Mur : VecteurMurs){

            if (Mur.getY() + CaseSize <= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point au dessus de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = max(ValCoNextMurY, Mur.getY() + CaseSize);
                }
                else if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = max(ValCoNextMurY, Mur.getY() + CaseSize);
                }
            }
            // Else if car (y + CaseSize) est forcément plus grand que (y) sachant que CaseSize >= 0
            else if (Mur.getY() <= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point au dessus de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = max(ValCoNextMurY, Mur.getY());
                }
                else if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = max(ValCoNextMurY, Mur.getY());
                }
            }

        }
        return ValCoNextMurY;

    }
    // Si direction vers le bas
    else if (Pac.DirectionActuelle == MapParamStrPac.find("TurnDown")->second){
        unsigned ValCoNextMurY (Parameters.MapParamUnsigned.find("WindowHeight")->second);
        for (Cposition & Mur : VecteurMurs){

            if (Mur.getY() >= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point au dessus de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = min(ValCoNextMurY, Mur.getY());
                }
                else if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = min(ValCoNextMurY, Mur.getY());
                }
            }
            // Else if car (y) est forcément plus petit que (y + CaseSize) sachant que CaseSize >= 0            
            else if (Mur.getY() + CaseSize >= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point au dessus de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = min(ValCoNextMurY, Mur.getY() + CaseSize);
                }
                else if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    ValCoNextMurY = min(ValCoNextMurY, Mur.getY() + CaseSize);
                }
            }

        }
        return ValCoNextMurY;

    }
    // Si direction à gauche
    else if (Pac.DirectionActuelle == MapParamStrPac.find("TurnLeft")->second){
        unsigned ValCoNextMurX (0);
        for (Cposition & Mur : VecteurMurs){

            if (Mur.getX() + CaseSize <= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à gauche de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = max(ValCoNextMurX, Mur.getX() + CaseSize);
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = max(ValCoNextMurX, Mur.getX() + CaseSize);
                }
            }
            // Else if car (x + CaseSize) est forcément plus grand que (x) sachant que CaseSize >= 0
            if (Mur.getX() <= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à gauche de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = max(ValCoNextMurX, Mur.getX());
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = max(ValCoNextMurX, Mur.getX());
                }
            }

        }
        return ValCoNextMurX;

    }
        // Si direction à droite
    else if (Pac.DirectionActuelle == Parameters.MapParamStrPac.find("TurnRight")->second){
        unsigned ValCoNextMurX (Parameters.MapParamUnsigned.find("WindowWidth")->second);
        for (Cposition & Mur : VecteurMurs){

            if (Mur.getX() <= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à gauche de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = min(ValCoNextMurX, Mur.getX());
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = min(ValCoNextMurX, Mur.getX());
                }
            }
            // Else if car (x) est forcément plus petit que (x + CaseSize) sachant que CaseSize >= 0            
            else if (Mur.getX() + CaseSize <= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à gauche de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = min(ValCoNextMurX, Mur.getX() + CaseSize);
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    ValCoNextMurX = min(ValCoNextMurX, Mur.getX() + CaseSize);
                }
            }

        }
        return ValCoNextMurX;

    }

}

void PossibleMursCollision (const PacMan & Pac, const unsigned & CaseSize, const vector<Cposition> & VecteurMurs, vector<Cposition> & VecteurPointsMursPossibles)
{
    VecteurPointsMursPossibles.resize(0);
    // Si direction vers le haut
    if (Pac.DirectionActuelle == MapParamStrPac.find("TurnUp")->second){
        for (Cposition & Mur : VecteurMurs){
            if (Mur.getY() <= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point au dessus de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    VecteurPointsMursPossibles.push_back(Mur);
                    VecteurPointsMursPossibles.push_back({Mur.getX(), Mur.getY() + CaseSize});
                }
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY()});
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY() + CaseSize});
                }
            }
        }
    }
    // Si direction vers le bas
    else if (Pac.DirectionActuelle == MapParamStrPac.find("TurnDown")->second){
        for (Cposition & Mur : VecteurMurs){
            if (Mur.getY() >= Pac.CenterPos.getY()){ // Traduction sur la fenetre : point en dessous de pacman
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() && Mur.getX() <= Pac.CenterPos.getX() + Pac.size){
                    VecteurPointsMursPossibles.push_back(Mur);
                    VecteurPointsMursPossibles.push_back({Mur.getX(), Mur.getY() + CaseSize});
                }
                if (Pac.CenterPos.getX() - Pac.size <= Mur.getX() + CaseSize && Mur.getX() + CaseSize <= Pac.CenterPos.getX() + Pac.size){
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY()});
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY() + CaseSize});
                }
            }
        }
    }
    // Si direction à gauche
    else if (Pac.DirectionActuelle == MapParamStrPac.find("TurnLeft")->second){
        for (Cposition & Mur : VecteurMurs){
            if (Mur.getX() <= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à gauche de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    VecteurPointsMursPossibles.push_back(Mur);
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY()});
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    VecteurPointsMursPossibles.push_back({Mur.getX(), Mur.getY() + CaseSize});
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY() + CaseSize});
                }
            }
        }
    }
    // Si direction à droite
    else if (Pac.DirectionActuelle == MapParamStrPac.find("TurnRight")->second){
        for (Cposition & Mur : VecteurMurs){
            if (Mur.getX() >= Pac.CenterPos.getX()){ // Traduction sur la fenetre : point à droite de pacman
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() && Mur.getY() <= Pac.CenterPos.getY() + Pac.size){
                    VecteurPointsMursPossibles.push_back(Mur);
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY()});
                }
                if (Pac.CenterPos.getY() - Pac.size <= Mur.getY() + CaseSize && Mur.getY() + CaseSize <= Pac.CenterPos.getY() + Pac.size){
                    VecteurPointsMursPossibles.push_back({Mur.getX(), Mur.getY() + CaseSize});
                    VecteurPointsMursPossibles.push_back({Mur.getX() + CaseSize, Mur.getY() + CaseSize});
                }
            }
        }
    }
}


/**
 * @brief 
 * @param[in] Pac : La struct contenant les caractéristiques nécessaires aux évaluations de collision
 * @param[in] Vitesse : La vitesse de déplacement de PacMan (en pixels)
 * @param[in] Parameters : La struct contenant tous les paramètres nécessaires à une partie
 * @param[in] VecteurPointsMursPossibles : Le vecteur contenant les positions des murs pouvant potentiellement entrer en collision avec pacman
 * @return Vrai et la distance entre extémité_mur et extémité_pacman + vitesse, -1 qui sera la nouvelle vitesse temporaire en attendant un changement de direction.
 * @fn 
*/
pair <bool, unsigned> CollisionPacMur (const PacMan & Pac, const unsigned & Vitesse, const map<string, char> & MapParamStrPac, const CMyParam & Parameters, /* const vector<Cposition> & VecteurMurs */, vector<Cposition> & VecteurPointsMursPossibles)
{
    // Ajout de cette condition pour éviter d'avoir à redéterminer les cases de collision possible et éviter de perdre du temps
    if (Pac.DirectionPrev != Pac.DirectionActuelle)
        PossibleMursCollision(Pac, Param.MapParamUnsigned.find("CaseSize")->second, VecteurMurs, VecteurPointsMursPossibles);
    
    // Déclaration des coordonnées d'extrémités dépendantes de la direction actuelle du pacman
    unsigned xVerif; // Coordonnées x max du point potentiel de contact
    unsigned yVerif; // Coordonnées y max du point potentiel de contact

    // Vérification en fonction de la direction actuelle du PacMan
    // Haut
    if (Pac.DirectionActuelle == MapParamStrPac.find("TurnUp")->second){
        yVerif = Pac.CenterPos.getY() - Pac.Size - Vitesse;
        for (CPosition & PointMur : VecteurPointsMursPossibles){
            if (PointMur.getY() >= yVerif)
                return {true, PointMur.getY() - yVerif - 1};
        }
        return {false, 0}; // Puisque pas de collision
    // Bas
    else if (Pac.Direction == MapParamStrPac.find("TurnDown")->second){
        yVerif = Pac.CenterPos.getY() + Pac.Size + Vitesse;
        for (CPosition & PointMur : VecteurPointsMursPossibles){
            if (PointMur.getY() <= yVerif)
                return {true, yVerif - PointMur.getY() - 1};
        }
        return {false, 0}; // Puisque pas de collision
    }
    // Gauche
    else if (Pac.Direction == MapParamStrPac.find("TurnLeft")->second){
        xVerif = Pac.CenterPos.getX() - Pac.Size - Vitesse;
        for (CPosition & PointMur : VecteurPointsMursPossibles){
            if (PointMur.getx() >= xVerif)
                return {true, PointMur.getx() - xVerif - 1};
        }
        return {false, 0}; // Puisque pas de collision
    }
    else if (Pac.Direction == MapParamStrPac.find("TurnRight")->second){
        xVerif = Pac.CenterPos.getX() + Pac.Size + Vitesse;
        for (CPosition & PointMur : VecteurPointsMursPossibles){
            if (PointMur.getx() <= xVerif)
                return {true, xVerif - PointMur.getx() - 1};
        }
        return {false, 0}; // Puisque pas de collision
    }
    else 
        return {false, 0}; // Puisque pas de collision car mauvaise direction en entrée
}